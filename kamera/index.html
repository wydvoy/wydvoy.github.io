<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kamera Vollbild & Foto-Download</title>
  <style>
    :root {
      --glass: rgba(0,0,0,0.55);
      --glass-light: rgba(255,255,255,0.75);
      --radius: 14px;
      --gap: 10px;
      --pad: 10px 12px;
      --shadow: 0 8px 28px rgba(0,0,0,0.25);
      --font: system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    html, body { height: 100%; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: var(--font); background: #000; color: #fff; }

    /* Video fullscreen */
    #video {
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      object-fit: cover;  /* füllt den Bildschirm */
      background: #000;
    }

    /* Overlays */
    .overlay {
      position: fixed; z-index: 2; display: flex; align-items: center; gap: var(--gap);
      backdrop-filter: blur(8px);
    }

    .top-left {
      top: 12px; left: 12px; padding: var(--pad);
      background: var(--glass); border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .top-left label { font-size: 14px; opacity: 0.9; margin-right: 4px; }

    .top-left select {
      appearance: none; -webkit-appearance: none; -moz-appearance: none;
      padding: 8px 36px 8px 10px; font: inherit; color: #fff; background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.25); border-radius: 10px; cursor: pointer;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>');
      background-repeat: no-repeat; background-position: right 8px center;
    }

    /* Shutter Button (rechts) */
    .shutter {
      right: 16px; top: 50%; transform: translateY(-50%);
      width: 76px; height: 76px; padding: 0; border: 0; border-radius: 50%;
      background: var(--glass-light); color: #000; cursor: pointer; outline: none;
      box-shadow: var(--shadow); display: grid; place-items: center;
      transition: transform 0.06s ease, filter 0.2s ease;
    }
    .shutter:hover { filter: brightness(1.05); }
    .shutter:active { transform: translateY(-50%) scale(0.96); }

    .shutter svg { width: 34px; height: 34px; }

    /* Message toast */
    .toast {
      left: 50%; bottom: 16px; transform: translateX(-50%);
      padding: 10px 14px; border-radius: 10px; background: var(--glass);
      box-shadow: var(--shadow); font-size: 14px; opacity: 0.95; max-width: 90vw;
    }
    .toast.error { background: rgba(189, 32, 32, 0.75); }
    .toast.success { background: rgba(0, 123, 67, 0.75); }

    /* Hide-only-for-print */
    @media print {
      .overlay, .toast { display: none !important; }
    }
  </style>
</head>
<body>
  <!-- Vollbild-Preview -->
  <video id="video" autoplay playsinline muted></video>

  <!-- Kamera-Auswahl oben links -->
  <div class="overlay top-left">
    <label for="cameraSelect">Kamera</label>
    <select id="cameraSelect" title="Kamera auswählen"></select>
  </div>

  <!-- Auslöser rechts -->
  <button id="shootBtn" class="overlay shutter" title="Foto aufnehmen (Leertaste)">
    <!-- einfache Kamera-Icon (inline SVG) -->
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <rect x="3" y="7" width="18" height="14" rx="3" stroke="currentColor" stroke-width="2"/>
      <path d="M9 7l1.5-2h3L15 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <circle cx="12" cy="14" r="4" stroke="currentColor" stroke-width="2"/>
    </svg>
  </button>

  <!-- Status-/Fehlermeldungen -->
  <div id="toast" class="overlay toast" role="status" aria-live="polite" style="display:none"></div>

  <script>
    (function () {
      const video = document.getElementById('video');
      const selectEl = document.getElementById('cameraSelect');
      const shootBtn = document.getElementById('shootBtn');
      const toast = document.getElementById('toast');

      let currentStream = null;
      let knownDevices = [];

      function showToast(message, type = 'info') {
        toast.textContent = message;
        toast.className = 'overlay toast' + (type ? ' ' + type : '');
        toast.style.display = 'block';
        clearTimeout(showToast._t);
        showToast._t = setTimeout(() => (toast.style.display = 'none'), 3500);
      }

      function isSecureContextOk() {
        // getUserMedia erfordert in modernen Browsern HTTPS oder localhost.
        return window.isSecureContext || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
      }

      async function ensurePermissionAndLabels() {
        // Holt initial Zugriff, damit enumerateDevices Labels liefert
        try {
          const s = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          s.getTracks().forEach(t => t.stop());
          return true;
        } catch (err) {
          showToast('Zugriff verweigert oder keine Kamera verfügbar: ' + err.message, 'error');
          throw err;
        }
      }

      async function listCameras() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        return devices.filter(d => d.kind === 'videoinput');
      }

      function populateSelect(devices, preferId) {
        selectEl.innerHTML = '';
        devices.forEach((d, i) => {
          const opt = document.createElement('option');
          opt.value = d.deviceId || '';
          opt.textContent = d.label || `Kamera ${i + 1}`;
          if ((preferId && d.deviceId === preferId) || (!preferId && i === 0)) opt.selected = true;
          selectEl.appendChild(opt);
        });
      }

      function buildConstraints(deviceId) {
        // Fallback: wenn keine deviceId vorhanden ist, verwende generische Constraints
        const base = { audio: false, video: { width: { ideal: 1920 }, height: { ideal: 1080 } } };
        if (deviceId) {
          base.video.deviceId = { exact: deviceId };
        }
        return base;
      }

      async function startStream(deviceId) {
        try {
          // Stoppe vorherigen Stream
          if (currentStream) currentStream.getTracks().forEach(t => t.stop());

          const stream = await navigator.mediaDevices.getUserMedia(buildConstraints(deviceId));
          currentStream = stream;
          video.srcObject = stream;

          // Warten bis Metadaten da sind -> dann play (hilft gegen "schwarzes Video")
          await new Promise((resolve) => {
            if (video.readyState >= 1) return resolve();
            const onLoaded = () => { video.removeEventListener('loadedmetadata', onLoaded); resolve(); };
            video.addEventListener('loadedmetadata', onLoaded);
          });

          // iOS/Autoplay-Policies: muted + playsinline sind bereits gesetzt
          await video.play().catch(() => { /* Ignorieren – Nutzerinteraktion (Klick) startet es auch */ });
        } catch (err) {
          showToast('Konnte Kamera nicht starten: ' + err.message, 'error');
        }
      }

      function timestampName() {
        const d = new Date();
        const p = n => String(n).padStart(2, '0');
        return `foto-${d.getFullYear()}${p(d.getMonth()+1)}${p(d.getDate())}-${p(d.getHours())}${p(d.getMinutes())}${p(d.getSeconds())}.png`;
      }

      function takePhoto() {
        if (!currentStream || !video.videoWidth) {
          showToast('Video noch nicht bereit …', 'error');
          return;
        }
        const w = video.videoWidth;
        const h = video.videoHeight;
        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, w, h);
        canvas.toBlob(blob => {
          if (!blob) { showToast('Fehler beim Erstellen des Bildes', 'error'); return; }
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = timestampName();
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1000);
        }, 'image/png');
      }

      async function init() {
        if (!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)) {
          showToast('Dein Browser unterstützt keine Kamera-APIs (mediaDevices).', 'error');
          return;
        }
        if (!isSecureContextOk()) {
          showToast('Hinweis: Über file:// kann die Kamera je nach Browser blockiert sein. Öffne die Datei über https:// oder http://localhost', 'error');
        }

        try {
          await ensurePermissionAndLabels();
          knownDevices = await listCameras();
          if (knownDevices.length === 0) {
            showToast('Keine Kamera gefunden.', 'error');
            return;
          }
          const last = localStorage.getItem('selectedCameraId');
          populateSelect(knownDevices, last && knownDevices.some(d => d.deviceId === last) ? last : undefined);
          await startStream(selectEl.value || undefined);
          localStorage.setItem('selectedCameraId', selectEl.value || '');
          showToast('Bereit. Drücke die Leertaste oder den Button für ein Foto.', 'success');
        } catch (_) { /* Fehler bereits getoastet */ }
      }

      // Events
      selectEl.addEventListener('change', async () => {
        localStorage.setItem('selectedCameraId', selectEl.value || '');
        await startStream(selectEl.value || undefined);
      });

      shootBtn.addEventListener('click', takePhoto);
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') { e.preventDefault(); takePhoto(); }
      });

      // Reagiere auf (Un)Plug von Geräten
      if (navigator.mediaDevices && 'addEventListener' in navigator.mediaDevices) {
        navigator.mediaDevices.addEventListener('devicechange', async () => {
          const before = selectEl.value;
          knownDevices = await listCameras();
          populateSelect(knownDevices, before);
          // Falls die ehem. Kamera entfernt wurde, starte erste verfügbare
          if (!knownDevices.some(d => d.deviceId === before)) {
            await startStream(selectEl.value || undefined);
            localStorage.setItem('selectedCameraId', selectEl.value || '');
          }
        });
      }

      // Start
      init();
    })();
  </script>
</body>
</html>
